-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module ParTreeSitter
  ( happyError
  , myLexer
  , pGrammar
  , pPreamble
  , pConstDecl
  , pListConstDecl
  , pGrammarBody
  , pInlines
  , pInline
  , pListInline
  , pName
  , pRules
  , pRule
  , pListRule
  , pExpression
  , pListExpression
  ) where

import Prelude

import qualified AbsTreeSitter
import LexTreeSitter

}

%name pGrammar Grammar
%name pPreamble Preamble
%name pConstDecl ConstDecl
%name pListConstDecl ListConstDecl
%name pGrammarBody GrammarBody
%name pInlines Inlines
%name pInline Inline
%name pListInline ListInline
%name pName Name
%name pRules Rules
%name pRule Rule
%name pListRule ListRule
%name pExpression Expression
%name pListExpression ListExpression
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '$'        { PT _ (TS _ 1)     }
  '('        { PT _ (TS _ 2)     }
  ')'        { PT _ (TS _ 3)     }
  ','        { PT _ (TS _ 4)     }
  '.'        { PT _ (TS _ 5)     }
  ':'        { PT _ (TS _ 6)     }
  ';'        { PT _ (TS _ 7)     }
  '='        { PT _ (TS _ 8)     }
  '=>'       { PT _ (TS _ 9)     }
  '['        { PT _ (TS _ 10)    }
  ']'        { PT _ (TS _ 11)    }
  'choice'   { PT _ (TS _ 12)    }
  'const'    { PT _ (TS _ 13)    }
  'exports'  { PT _ (TS _ 14)    }
  'grammar'  { PT _ (TS _ 15)    }
  'inline'   { PT _ (TS _ 16)    }
  'module'   { PT _ (TS _ 17)    }
  'name'     { PT _ (TS _ 18)    }
  'null'     { PT _ (TS _ 19)    }
  'optional' { PT _ (TS _ 20)    }
  'repeat'   { PT _ (TS _ 21)    }
  'repeat1'  { PT _ (TS _ 22)    }
  'rules'    { PT _ (TS _ 23)    }
  'seq'      { PT _ (TS _ 24)    }
  '{'        { PT _ (TS _ 25)    }
  '}'        { PT _ (TS _ 26)    }
  L_quoted   { PT _ (TL $$)      }
  L_Id       { PT _ (T_Id $$)    }
  L_RegEx    { PT _ (T_RegEx $$) }

%%

String  :: { String }
String   : L_quoted { $1 }

Id :: { AbsTreeSitter.Id }
Id  : L_Id { AbsTreeSitter.Id $1 }

RegEx :: { AbsTreeSitter.RegEx }
RegEx  : L_RegEx { AbsTreeSitter.RegEx $1 }

Grammar :: { AbsTreeSitter.Grammar }
Grammar
  : Preamble 'module' '.' 'exports' '=' 'grammar' '(' '{' GrammarBody '}' ')' ';' { AbsTreeSitter.Grammar $1 $9 }

Preamble :: { AbsTreeSitter.Preamble }
Preamble : ListConstDecl { AbsTreeSitter.Preamble $1 }

ConstDecl :: { AbsTreeSitter.ConstDecl }
ConstDecl : 'const' Id '=' String { AbsTreeSitter.ConstDecl $2 $4 }

ListConstDecl :: { [AbsTreeSitter.ConstDecl] }
ListConstDecl
  : {- empty -} { [] } | ConstDecl ';' ListConstDecl { (:) $1 $3 }

GrammarBody :: { AbsTreeSitter.GrammarBody }
GrammarBody
  : Name ',' Rules ',' Inlines ',' { AbsTreeSitter.GrammarBody $1 $3 $5 }

Inlines :: { AbsTreeSitter.Inlines }
Inlines
  : 'inline' ':' '$' '=>' '[' ListInline ']' { AbsTreeSitter.Inlines $6 }

Inline :: { AbsTreeSitter.Inline }
Inline : '$' '.' Id { AbsTreeSitter.InlineSymbol $3 }

ListInline :: { [AbsTreeSitter.Inline] }
ListInline
  : {- empty -} { [] } | Inline ',' ListInline { (:) $1 $3 }

Name :: { AbsTreeSitter.Name }
Name : 'name' ':' String { AbsTreeSitter.Name $3 }

Rules :: { AbsTreeSitter.Rules }
Rules : 'rules' ':' '{' ListRule '}' { AbsTreeSitter.Rules $4 }

Rule :: { AbsTreeSitter.Rule }
Rule : Id ':' '$' '=>' Expression { AbsTreeSitter.Rule $1 $5 }

ListRule :: { [AbsTreeSitter.Rule] }
ListRule : {- empty -} { [] } | Rule ',' ListRule { (:) $1 $3 }

Expression :: { AbsTreeSitter.Expression }
Expression
  : 'choice' '(' ListExpression ')' { AbsTreeSitter.Choice $3 }
  | 'seq' '(' ListExpression ')' { AbsTreeSitter.Seq $3 }
  | 'repeat' '(' Expression ')' { AbsTreeSitter.Repeat $3 }
  | 'repeat1' '(' Expression ')' { AbsTreeSitter.Repeat1 $3 }
  | 'optional' '(' Expression ')' { AbsTreeSitter.Optional $3 }
  | '$' '.' Id { AbsTreeSitter.Symbol $3 }
  | Id { AbsTreeSitter.Const $1 }
  | String { AbsTreeSitter.Literal $1 }
  | RegEx { AbsTreeSitter.Regex $1 }
  | 'null' { AbsTreeSitter.Null }

ListExpression :: { [AbsTreeSitter.Expression] }
ListExpression
  : {- empty -} { [] }
  | Expression { (:[]) $1 }
  | Expression ',' ListExpression { (:) $1 $3 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

